### DP算法

dp算法一般用来解决一些最优化的问题，是运筹学的一个分支。

#### 核心概念

##### 最优子结构
dp问题，一般可以将问题分解为多个子问题，子问题具有相同类似的的结构，通过状态转移方程，能够通过子问题来解决父问题，是一种自底向上解决问题的方法。

core
- 子问题的输出只跟当前的输入有关联，和**历史状态无关**，确定的输入给出确定的输出
- 子问题的定义实质上是定义如何用某些状态来描述问题，依赖于经验

##### 状态转移函数
如何通过子问题来获得父问题的答案？通过合适的状态转移方程，能够将子问题的最优解转移为父问题的最优解。

##### 用状态来描述问题
一个问题可以从多个角度或者维度去描述，如何用恰当的状态来描述子问题依赖于经验。

core
- 从状态转移方程而言，方程不能涉及过多的历史状态
- 从具体问题分析，该维度定义问题，必须使状态转移方程好描述

动态规划是**分而治之**思想的体现，解决问题的思路对应着两个矛盾的方面

1. 从小问题逐步迭代出大问题的解决答案
2. 从大问题出发，将问题拆分为子问题，直到平凡解，在多路递归的情况下，问题规模往往呈指数递增，通过cache缓存可以有效解决问题

#### example

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


例子1
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。


例子2
输入：nums = [0,1,0,3,2,3]
输出：4


例子3
输入：nums = [7,7,7,7,7,7,7]
输出：1
```


```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {
    let dp = Array(nums.length);

    dp[0] = 1;
    for (let i = 1; i < nums.length; i++) {
        let maxLen = 1;
        for (let j = i - 1; j >= 0; j--) {
            if (nums[j] < nums[i]) {
                maxLen = maxLen > dp[j] + 1 ? maxLen : dp[j] + 1;
            }
        }
        dp[i] = maxLen;
    }
    return Math.max(...dp);
};
```
