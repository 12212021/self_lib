### 定义
图可以定义为G = (V, E)，约定集合V和集合E均为有限集，其规模分别为|V|,|E|
- 集合V中元素称为顶点（vertex）
- 集合E中元素对应一对顶点(u, v)，表示顶点之间存在某种关系，称为边（edge）

#### 无向图
边(u, v)与边(v, u)对等，集合E中**所有**的边均没有方向，图G称为无向图

#### 混合图
集合E中存在无向边也存在有向边，则图G称为混合图

#### 有向图
边(u, v)与边(v, u)不对等，集合E中所有的边均存在方向，图G称为有向图
<!--$无向图和混合图均可以转化为有向图$-->

### 度
- 在无向图中，与顶点v关联的边数称为v的度数（degree）
- 对于有向边e = (u, v) e称为u的出边（outgoing edge）记做outdeg(v)，v的入边（incoming edge）记做记做indeg(v)


### 简单图
不含有任何自环（self-loop）的图称为简单图（simple graph），是图数据结构讨论的主要对象

### 通路与环路（path）

#### 通路
由m+1个顶点和m个边交替构成的一个序列
π = {v<sub>0</sub>, e<sub>1</sub>, v<sub>1</sub>, e<sub>2</sub>, v<sub>2</sub>, e<sub>3</sub>, ..., e<sub>m</sub>, v<sub>m</sub>}，对于任何的0 < i <= m，都有ei = (v<sub>i-1</sub>, v<sub>i</sub>)，其中边的总数m，亦称为通路的长度，记做|π| = m

#### 环路
对于长度m >= 1的通路，若起始顶点相同（V<sub>0</sub> = V<sub>m</sub>），称为环路，{A, B, A}为一个环路，不含有任何环路的有向图称为**有向无环图**

环路上边必须是互异的，但是顶点可能重复，如果除了V<sub>0</sub> = V<sub>m</sub>，其他顶点都是互异的，则称为**简单环路**，如果经过图中**各条边一次且恰好一次**的环路，称为**欧拉环路**，经过**各个顶点一次且恰好一次**的环路称为**哈密尔顿环路**

### 权重
有一些图需要表现边的细节，比方说城市之间的铁路连接，除了方向，还会有长度、承运能力、运输成本等额信息。

通过一个权重函数，为每一个边指定一个权重weight，wt(e)表示边e的权重。各条边均带权重的图称为带权图(weighted graph)，记做G(V, E, wt())

### 复杂度
图算法的时间复杂度和空间复杂度是由顶点数和边数决定的(v + e)，无论顶点数为多少，边最少可以为0，最多包含边数为
- 无向图v(v - 1)/2，每一对顶点最多贡献一条边
- 有向图v(v - 1)，每一对顶点最多贡献两条边

### 抽象数据类型接口


#### 图边支持的操作接口
| 操作接口  | 功能描述  |
|-----------------|--------------|
| e()  | 边总数|E|  |
| exits(v, u)  | 判断边(v, u)是否存在  |
| insert(v, u)  | 引入从顶点v到u的联边  |
| remove(v, u)  | 删除从顶点v到u的联边  |
| type(v, u)  | 边在遍历树的类型  |
| edge(v, u)  | 边对应的数据域  |
| wright(v, u)  | 边的权重  |


#### 图顶点支持的操作接口


| 操作接口  | 功能描述  |
|---|---|
| n()  | 顶点总数|N|  |
| insert(v)  | 在顶点集V中插入顶点v  |
| remove(v)  | 在顶点集合V中移除点点v  |
| inDegree(v)  | 顶点v的入度  |
| outDegree(v)  | 顶点v的出度  |
| firstNbr(v)  | 顶点v的首个邻接顶点  |
| nextNbr(v, u)  | 在v的邻接顶点中，u的后继  |
| status(v)  | 顶点v的状态  |
| dTime(v)  | 顶点v的时间标签  |
| fTime(v)  | 顶点v的时间标签  |
| parent(v)  | 顶点v在遍历树中的父节点  |
| priority(v)  | 顶点v在遍历树中的权重  |


### 图的实现方式

#### 邻接矩阵
采用方阵来表示图结构，方阵的每个单元描述顶点和顶点之间的关系
![image.png](https://i.loli.net/2021/10/29/p8i7UWSeLGnNFOw.png)

性能：针对静态操作，邻接矩阵能够在常数时间复杂度内找到元素，但是在动态操作顶点（插入顶点、删除顶点）时，需要对向量进行整体修改，但就分摊意义而言，其复杂度不超过O(n)


空间复杂度：邻接矩阵的依赖于向量实现，向量的装填因子一般为50%，所以邻接矩阵的空间复杂度不超过O(n<sup>2</sup>)，对于一般的图而言，邻接矩阵耗费空间巨大。

#### 邻接表
以链表的形式来实现图，称为邻接表实现

![image.png](https://i.loli.net/2021/10/29/xo5L6jDKS7nHWAV.png)

性能：邻接表的空间性能为(n + e)，不超过图的边和顶点规模，判断边是否在图中存在的时间性能需要O(n)，但是对于顶点的动态操作，插入仅需要常数时间；删除仍需要O(e)时间。


邻接表作为图的主要实现方式原因：尽管邻接表访问单条边的效率并不算高， 却十分擅长于以批量方式，处理同一顶点的所有关
联边。在以下图遍历等算法中，这是典型的处理流程和模式。 比如，为枚举从顶点v发出的所有
边， 现在仅需(1 + outDegree(v))而非O(n)时间。


### 广度遍历优先算法
BFS：越早被访问的节点，其邻居也优先被访问


前沿集：已经被访问但是存在邻居为被访问的节点构成的集合称为前沿集


BFS：反复从前沿集中找到最早被访问的节点V，若其邻居已均被访问，则将其逐出前沿集；否则，任选其一个尚为被访问的邻居节点，将其加入到前沿集中。


### 深度遍历优先算法
DFS：优先选取最后一个被访问的顶点的邻居


### 拓扑排序
定义：给定一个有向图，如何在与该有向图“相容”的前提下，将所有的顶点排成一个序列，该序列称为有向图的一个拓扑排序

相容：每一个顶点v都不会通过边e指向改序列中的前驱顶点v


若改有向图为有向无环图，则必然存在拓扑排序，且不唯一，反之亦然。

#### BFS算法生成拓扑排序
将顶点入度为0的节点v以及其关联边从图G取出，则剩余的G'仍然为有向无环图，从递归的角度来看，一旦拿到G'的拓扑排序，则将v节点作为**最大顶点**插入，可以得到图G的拓扑排序


详细过程
1. 将入度为0的节点v筛选出来，进入队列
2. 从队列中进行出队，对当前节点x，遍历x的**出度**指向的节点y，将y的**入度**进行`减一操作`
3. 对y进行减一操作后，判断y的入度是否为0，若为0，则将y进行入队
4. 循环流程直到队列为空，节点的**出队顺序**对应一个拓扑排序


注意：BFS能够检测图中是否存在环

对于上述过程，当队列为空的时候对应两种情况
- 图为空，则此时队列出队顺序对应一个拓扑排序
- 图不为空，但是不存在入度为0的节点v，则此时图中必然存在环

示意图如下
![image.png](https://i.loli.net/2021/11/01/YQayBC987JjPVi2.png)

#### DFS算法生成拓扑排序
若m节点有`有向边`指向n，则可定义m依赖于n


原理：针对节点v，对v所有的依赖（出度指向节点）进行搜索，当v所有出度连接的节点完成了搜索，则v节点也完成了搜索，可入栈，当图所有节点搜索完成的时候，栈的倒序对应一个拓扑排序。（dfs的深度优先搜索是逆向思维）


DFS算法定义细节如下
1. 设置栈S，设置图中所有的节点v的状态为`未搜索`
2. 针对节点v，标注节点v状态为`搜索中`，对v所有依赖（出度指向节点）进行递归搜索
3. 若节点v没有依赖或者其所有依赖节点搜索均完成，将v入栈S，设置v节点的状态为`搜索完成`
4. 栈S，从栈底到栈顶对应一个拓扑排序


备注：在DFS深搜的过程中，若搜索到节点的状态为`搜索中`，证明图中存在环，即不存在拓扑排序。
