### 定义
图可以定义为G = (V, E)，约定集合V和集合E均为有限集，其规模分别为|V|,|E|
- 集合V中元素称为顶点（vertex）
- 集合E中元素对应一对顶点(u, v)，表示顶点之间存在某种关系，称为边（edge）

#### 无向图
边(u, v)与边(v, u)对等，集合E中**所有**的边均没有方向，图G称为无向图

#### 混合图
集合E中存在无向边也存在有向边，则图G称为混合图

#### 有向图
边(u, v)与边(v, u)不对等，集合E中所有的边均存在方向，图G称为有向图
<!--$无向图和混合图均可以转化为有向图$-->

### 度
- 在无向图中，与顶点v关联的边数称为v的度数（degree）
- 对于有向边e = (u, v) e称为u的出边（outgoing edge）记做outdeg(v)，v的入边（incoming edge）记做记做indeg(v)


### 简单图
不含有任何自环（self-loop）的图称为简单图（simple graph），是图数据结构讨论的主要对象

### 通路与环路（path）

#### 通路
由m+1个顶点和m个边交替构成的一个序列
π = {v<sub>0</sub>, e<sub>1</sub>, v<sub>1</sub>, e<sub>2</sub>, v<sub>2</sub>, e<sub>3</sub>, ..., e<sub>m</sub>, v<sub>m</sub>}，对于任何的0 < i <= m，都有ei = (v<sub>i-1</sub>, v<sub>i</sub>)，其中边的总数m，亦称为通路的长度，记做|π| = m

#### 环路
对于长度m >= 1的通路，若起始顶点相同（V<sub>0</sub> = V<sub>m</sub>），称为环路，{A, B, A}为一个环路，不含有任何环路的有向图称为**有向无环图**

环路上边必须是互异的，但是顶点可能重复，如果除了V<sub>0</sub> = V<sub>m</sub>，其他顶点都是互异的，则称为**简单环路**，如果经过图中**各条边一次且恰好一次**的环路，称为**欧拉环路**，经过**各个顶点一次且恰好一次**的环路称为**哈密尔顿环路**

### 权重
有一些图需要表现边的细节，比方说城市之间的铁路连接，除了方向，还会有长度、承运能力、运输成本等额信息。

通过一个权重函数，为每一个边指定一个权重weight，wt(e)表示边e的权重。各条边均带权重的图称为带权图(weighted graph)，记做G(V, E, wt())

### 复杂度
图算法的时间复杂度和空间复杂度是由顶点数和边数决定的(v + e)，无论顶点数为多少，边最少可以为0，最多包含边数为
- 无向图v(v - 1)/2，每一对顶点最多贡献一条边
- 有向图v(v - 1)，每一对顶点最多贡献两条边

### 抽象数据类型接口


#### 图边支持的操作接口
| 操作接口  | 功能描述  |
|-----------------|--------------|
| e()  | 边总数|E|  |
| exits(v, u)  | 判断边(v, u)是否存在  |
| insert(v, u)  | 引入从顶点v到u的联边  |
| remove(v, u)  | 删除从顶点v到u的联边  |
| type(v, u)  | 边在遍历树的类型  |
| edge(v, u)  | 边对应的数据域  |
| wright(v, u)  | 边的权重  |


#### 图顶点支持的操作接口


| 操作接口  | 功能描述  |
|---|---|
| n()  | 顶点总数|N|  |
| insert(v)  | 在顶点集V中插入顶点v  |
| remove(v)  | 在顶点集合V中移除点点v  |
| inDegree(v)  | 顶点v的入度  |
| outDegree(v)  | 顶点v的出度  |
| firstNbr(v)  | 顶点v的首个邻接顶点  |
| nextNbr(v, u)  | 在v的邻接顶点中，u的后继  |
| status(v)  | 顶点v的状态  |
| dTime(v)  | 顶点v的时间标签  |
| fTime(v)  | 顶点v的时间标签  |
| parent(v)  | 顶点v在遍历树中的父节点  |
| priority(v)  | 顶点v在遍历树中的权重  |


### 图的实现方式

#### 邻接矩阵
采用方阵来表示图结构，方阵的每个单元描述顶点和顶点之间的关系
![image.png](https://i.loli.net/2021/10/29/p8i7UWSeLGnNFOw.png)

性能：针对静态操作，邻接矩阵能够在常数时间复杂度内找到元素，但是在动态操作顶点（插入顶点、删除顶点）时，需要对向量进行整体修改，但就分摊意义而言，其复杂度不超过O(n)


空间复杂度：邻接矩阵的依赖于向量实现，向量的装填因子一般为50%，所以邻接矩阵的空间复杂度不超过O(n<sup>2</sup>)，对于一般的图而言，邻接矩阵耗费空间巨大。

#### 邻接表
以链表的形式来实现图，称为邻接表实现

![image.png](https://i.loli.net/2021/10/29/xo5L6jDKS7nHWAV.png)

性能：邻接表的空间性能为(n + e)，不超过图的边和顶点规模，判断边是否在图中存在的时间性能需要O(n)，但是对于顶点的动态操作，插入仅需要常数时间；删除仍需要O(e)时间。


邻接表作为图的主要实现方式原因：尽管邻接表访问单条边的效率并不算高， 却十分擅长于以批量方式，处理同一顶点的所有关
联边。在以下图遍历等算法中，这是典型的处理流程和模式。 比如，为枚举从顶点v发出的所有
边， 现在仅需(1 + outDegree(v))而非O(n)时间。
